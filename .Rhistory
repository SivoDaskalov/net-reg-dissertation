return(expressionLevels)
}
generateExpressionLevelsFrame = function(n, transFactorsCount, regulatedGenesPerTF){
expressionLevelsFrame = c()
for(i in 1:n){
expressionLevelsFrame = rbind(expressionLevelsFrame, generateExpressionLevels(transFactorsCount, regulatedGenesPerTF))
}
return(data.frame(expressionLevelsFrame))
}
X = generateExpressionLevelsFrame(n = 10, transFactorsCount = 200, regulatedGenesPerTF = 10)
simulateResponseValues = function(X, betas){
betas = as.numeric(betas)
noiseVar = sum((betas-mean(betas))^2)/4
noise = rnorm(nrow(X), mean = 0, sd = sqrt(noiseVar))
weighedX = sweep(x = X, 2, betas, "*")
sumWeighedX = rowSums(weighedX)
Y = sumWeighedX + noise
return(Y)
}
Y1 = simulateResponseValues(X, betas[1,])
Y2 = simulateResponseValues(X, betas[2,])
Y3 = simulateResponseValues(X, betas[3,])
Y4 = simulateResponseValues(X, betas[4,])
X = generateExpressionLevelsFrame(n = 100, transFactorsCount = 200, regulatedGenesPerTF = 10)
simulateResponseValues = function(X, betas){
betas = as.numeric(betas)
noiseVar = sum((betas-mean(betas))^2)/4
noise = rnorm(nrow(X), mean = 0, sd = sqrt(noiseVar))
weighedX = sweep(x = X, 2, betas, "*")
sumWeighedX = rowSums(weighedX)
Y = sumWeighedX + noise
return(Y)
}
Y1 = simulateResponseValues(X, betas[1,])
Y2 = simulateResponseValues(X, betas[2,])
Y3 = simulateResponseValues(X, betas[3,])
Y4 = simulateResponseValues(X, betas[4,])
generateBetaVector = function(TF1, TF2, TF3, TF4, denominator, negative, positive, unrelatedTransFactorCount){
EL1 = c(TF1, rep(-TF1/denominator, negative), rep(TF1/denominator, positive))
EL2 = c(TF2, rep(-TF2/denominator, negative), rep(TF2/denominator, positive))
EL3 = c(TF3, rep(-TF3/denominator, negative), rep(TF3/denominator, positive))
EL4 = c(TF4, rep(-TF4/denominator, negative), rep(TF4/denominator, positive))
ELU = rep(0, unrelatedTransFactorCount*(1+positive+negative))
return(c(EL1, EL2, EL3, EL4, ELU))
}
createBetaFrame = function(){
M1 = generateBetaVector(TF1 = 5, TF2 = -5, TF3 = 3, TF4 = -3, denominator = sqrt(10), negative = 0, positive = 10, unrelatedTransFactorCount = 196)
M2 = generateBetaVector(TF1 = 5, TF2 = -5, TF3 = 3, TF4 = -3, denominator = sqrt(10), negative = 3, positive = 7, unrelatedTransFactorCount = 196)
M3 = generateBetaVector(TF1 = 5, TF2 = -5, TF3 = 3, TF4 = -3, denominator = 10, negative = 0, positive = 10, unrelatedTransFactorCount = 196)
M4 = generateBetaVector(TF1 = 5, TF2 = -5, TF3 = 3, TF4 = -3, denominator = 10, negative = 3, positive = 7, unrelatedTransFactorCount = 196)
betas = data.frame(rbind(M1,M2,M3,M4))
return(betas)
}
generateExpressionLevels = function(transFactorsCount, regulatedGenesPerTF){
TF = rnorm(n = transFactorsCount, mean = 0, sd = 1)
expressionLevels = c()
for(i in 1:length(TF)){
expressionLevels = c(expressionLevels, TF[i], rnorm(regulatedGenesPerTF, 0.7*TF[i], 0.51))
}
return(expressionLevels)
}
generateExpressionLevelsFrame = function(n, transFactorsCount, regulatedGenesPerTF){
expressionLevelsFrame = c()
for(i in 1:n){
expressionLevelsFrame = rbind(expressionLevelsFrame, generateExpressionLevels(transFactorsCount, regulatedGenesPerTF))
}
return(data.frame(expressionLevelsFrame))
}
simulateResponseValues = function(X, betas){
betas = as.numeric(betas)
noiseVar = sum((betas-mean(betas))^2)/4
noise = rnorm(nrow(X), mean = 0, sd = sqrt(noiseVar))
weighedX = sweep(x = X, 2, betas, "*")
sumWeighedX = rowSums(weighedX)
Y = sumWeighedX + noise
return(Y)
}
betas = createBetaFrame()
X = generateExpressionLevelsFrame(n = 100, transFactorsCount = 200, regulatedGenesPerTF = 10)
Y1 = simulateResponseValues(X, betas[1,])
Y2 = simulateResponseValues(X, betas[2,])
Y3 = simulateResponseValues(X, betas[3,])
Y4 = simulateResponseValues(X, betas[4,])
remove(betas)
library(glmnet)
cvGrace <- function(X, Y, L, lambda.L, lambda.1, lambda.2, K = 10){
lambda.1 <- unique(sort(lambda.1, decreasing = TRUE))
lambda.L <- unique(sort(lambda.L, decreasing = TRUE))
lambda.2 <- unique(sort(lambda.2, decreasing = TRUE))
p <- ncol(X)
n <- nrow(X)
ERRlist = c()
for(iL in 1:length(lambda.L)){
lL <- lambda.L[iL]
for(i2 in 1:length(lambda.2)){
l2 <- lambda.2[i2]
Lnew <- lL * L + l2 * diag(p)
eL <- eigen(Lnew)
if( sum(eL$values<=0)>0 ){next}
S <- eL$vectors %*% sqrt(diag(eL$values))
l2star <- 1
l1star <- lambda.1
Xstar <- rbind(X, sqrt(l2star) * t(S)) / sqrt(1 + l2star)
Ystar <- c(Y, rep(0, p))
gammastar <- l1star / sqrt(1 + l2star) / 2 / (n + p)
for( i1 in 1:length(gammastar)    ){
temp_gammastar =  c(gammastar[i1] + 0.01, gammastar[i1])
cvres <- cv.glmnet(Xstar, Ystar, lambda = temp_gammastar, intercept = FALSE, standardize = FALSE, nfolds = K)
if(!is.na(cvres$cvm[2])){
ERRlist = rbind( ERRlist, c( lambda.1[i1] , lL, l2, cvres$cvm[2] )  )
}
}
}
}
colnames(ERRlist)=c("lambda.1","lambda.L","lambda.2","cvm")
return(ERRlist)
}
grace <- function(Y, X, L, lambda.L, lambda.1 = 0, lambda.2 = 0, normalize.L = FALSE, K = 10){
lambda.L <- unique(sort(lambda.L, decreasing = TRUE))
lambda.1 <- unique(sort(lambda.1, decreasing = TRUE))
lambda.2 <- unique(sort(lambda.2, decreasing = TRUE))
ori.Y <- Y
ori.X <- X
if(!is.null(ncol(Y))){
stop("Error: Y is not a vector.")
}
if(length(Y) != nrow(X)){
stop("Error: Dimensions of X and Y do not match.")
}
if(!isSymmetric(L)){
stop("Error: L is not a symmetric matrix.")
}
if(ncol(X) != ncol(L)){
stop("Error: Dimensions of X and L do not match.")
}
if(min(lambda.L) < 0 | min(lambda.2) < 0 | min(lambda.1) < 0){
stop("Error: Grace tuning parameters must be non-negative.")
}
if(min(lambda.L) == 0 & min(lambda.2) == 0){
stop("Error: At least one of the grace tuning parameters must be positive.")
}
Y <- Y - mean(Y)  # Center Y
n <- nrow(X)
p <- ncol(X)
scale.fac <- attr(scale(X), "scaled:scale")
X <- scale(X)     # Standardize X
if(normalize.L){
diag(L)[diag(L) == 0] <- 1
L <- diag(1 / sqrt(diag(L))) %*% L %*% diag(1 / sqrt(diag(L)))  # Normalize L
}
# If more than one tuning parameter is provided, perform K-fold cross-validation
if((length(lambda.L) > 1) | (length(lambda.1) > 1) | (length(lambda.2) > 1)){
parameters <- cvGrace(X, Y, L, lambda.L, lambda.1, lambda.2, K)
tun = parameters[parameters[,4]==min(parameters[,4]), ]
if(length(dim(tun))==2 ){
lambda.1 <- tun[1,1]
lambda.L <- tun[1,2]
lambda.2 <- tun[1,3]
}else{
lambda.1 <- tun[1]
lambda.L <- tun[2]
lambda.2 <- tun[3]
}
}
# See Li & Li (2008) for reference
Lnew <- lambda.L * L + lambda.2 * diag(p)
eL <- eigen(Lnew)
S <- eL$vectors %*% sqrt(diag(eL$values))
l2star <- 1
l1star <- lambda.1
Xstar <- rbind(X, sqrt(l2star) * t(S)) / sqrt(1 + l2star)
Ystar <- c(Y, rep(0, p))
gammastar <- l1star / sqrt(1 + l2star) / 2 / (n + p)
graceFit <- glmnet(Xstar, Ystar, lambda = gammastar, intercept = FALSE, standardize = FALSE, thresh = 1e-11)
betahatstar <- graceFit$beta[, 1]
betahat <- betahatstar / sqrt(1 + l2star)
truebetahat <- betahat / scale.fac  # Scale back coefficient estimate
truealphahat <- mean(ori.Y - ori.X %*% truebetahat)
return(list( ParameterEstimation = list(parameterCV=parameters, parameterMin=tun),
GraceFit = graceFit,
Beta=list(intercept = truealphahat, beta = truebetahat)))
}
generateBetaVector = function(TF1, TF2, TF3, TF4, denominator, negative, positive, unrelatedTransFactorCount){
EL1 = c(TF1, rep(-TF1/denominator, negative), rep(TF1/denominator, positive))
EL2 = c(TF2, rep(-TF2/denominator, negative), rep(TF2/denominator, positive))
EL3 = c(TF3, rep(-TF3/denominator, negative), rep(TF3/denominator, positive))
EL4 = c(TF4, rep(-TF4/denominator, negative), rep(TF4/denominator, positive))
ELU = rep(0, unrelatedTransFactorCount*(1+positive+negative))
return(c(EL1, EL2, EL3, EL4, ELU))
}
createBetaFrame = function(){
M1 = generateBetaVector(TF1 = 5, TF2 = -5, TF3 = 3, TF4 = -3, denominator = sqrt(10), negative = 0, positive = 10, unrelatedTransFactorCount = 196)
M2 = generateBetaVector(TF1 = 5, TF2 = -5, TF3 = 3, TF4 = -3, denominator = sqrt(10), negative = 3, positive = 7, unrelatedTransFactorCount = 196)
M3 = generateBetaVector(TF1 = 5, TF2 = -5, TF3 = 3, TF4 = -3, denominator = 10, negative = 0, positive = 10, unrelatedTransFactorCount = 196)
M4 = generateBetaVector(TF1 = 5, TF2 = -5, TF3 = 3, TF4 = -3, denominator = 10, negative = 3, positive = 7, unrelatedTransFactorCount = 196)
betas = data.frame(rbind(M1,M2,M3,M4))
return(betas)
}
generateExpressionLevels = function(transFactorsCount, regulatedGenesPerTF){
TF = rnorm(n = transFactorsCount, mean = 0, sd = 1)
expressionLevels = c()
for(i in 1:length(TF)){
expressionLevels = c(expressionLevels, TF[i], rnorm(regulatedGenesPerTF, 0.7*TF[i], sqrt(0.51)))
}
return(expressionLevels)
}
generateExpressionLevelsFrame = function(n, transFactorsCount, regulatedGenesPerTF){
expressionLevelsFrame = c()
for(i in 1:n){
expressionLevelsFrame = rbind(expressionLevelsFrame, generateExpressionLevels(transFactorsCount, regulatedGenesPerTF))
}
return(data.frame(expressionLevelsFrame))
}
simulateResponseValues = function(X, betas){
betas = as.numeric(betas)
noiseVar = sum((betas-mean(betas))^2)/4
noise = rnorm(nrow(X), mean = 0, sd = sqrt(noiseVar))
weighedX = sweep(x = X, 2, betas, "*")
sumWeighedX = rowSums(weighedX)
Y = sumWeighedX + noise
return(Y)
}
generateBetaVector = function(TF1, TF2, TF3, TF4, denominator, negative, positive, unrelatedTransFactorCount){
EL1 = c(TF1, rep(-TF1/denominator, negative), rep(TF1/denominator, positive))
EL2 = c(TF2, rep(-TF2/denominator, negative), rep(TF2/denominator, positive))
EL3 = c(TF3, rep(-TF3/denominator, negative), rep(TF3/denominator, positive))
EL4 = c(TF4, rep(-TF4/denominator, negative), rep(TF4/denominator, positive))
ELU = rep(0, unrelatedTransFactorCount*(1+positive+negative))
return(c(EL1, EL2, EL3, EL4, ELU))
}
createBetaFrame = function(){
M1 = generateBetaVector(TF1 = 5, TF2 = -5, TF3 = 3, TF4 = -3, denominator = sqrt(10), negative = 0, positive = 10, unrelatedTransFactorCount = 196)
M2 = generateBetaVector(TF1 = 5, TF2 = -5, TF3 = 3, TF4 = -3, denominator = sqrt(10), negative = 3, positive = 7, unrelatedTransFactorCount = 196)
M3 = generateBetaVector(TF1 = 5, TF2 = -5, TF3 = 3, TF4 = -3, denominator = 10, negative = 0, positive = 10, unrelatedTransFactorCount = 196)
M4 = generateBetaVector(TF1 = 5, TF2 = -5, TF3 = 3, TF4 = -3, denominator = 10, negative = 3, positive = 7, unrelatedTransFactorCount = 196)
betas = data.frame(rbind(M1,M2,M3,M4))
return(betas)
}
generateExpressionLevels = function(transFactorsCount, regulatedGenesPerTF){
TF = rnorm(n = transFactorsCount, mean = 0, sd = 1)
expressionLevels = c()
for(i in 1:length(TF)){
expressionLevels = c(expressionLevels, TF[i], rnorm(regulatedGenesPerTF, 0.7*TF[i], sqrt(0.51)))
}
return(expressionLevels)
}
generateExpressionLevelsFrame = function(n, transFactorsCount, regulatedGenesPerTF){
expressionLevelsFrame = c()
for(i in 1:n){
expressionLevelsFrame = rbind(expressionLevelsFrame, generateExpressionLevels(transFactorsCount, regulatedGenesPerTF))
}
return(data.frame(expressionLevelsFrame))
}
simulateResponseValues = function(X, betas){
betas = as.numeric(betas)
noiseVar = sum((betas-mean(betas))^2)/4
noise = rnorm(nrow(X), mean = 0, sd = sqrt(noiseVar))
weighedX = sweep(x = X, 2, betas, "*")
sumWeighedX = rowSums(weighedX)
Y = sumWeighedX + noise
return(Y)
}
generateNetwork = function(transFactorsCount, regulatedGenesPerTF){
network = matrix(0, transFactorsCount * regulatedGenesPerTF, 2)
for(i in 0:transFactorsCount-1){
for(j in 1:regulatedGenesPerTF){
network[i * regulatedGenesPerTF + j, 1] = i * (regulatedGenesPerTF + 1) + 1
network[i * regulatedGenesPerTF + j, 2] = i * (regulatedGenesPerTF + 1) + j + 1
}
}
return(network)
}
normalize = function(X, Y){
Xmu<-apply(X, 2, mean)
Xsd<-sqrt(apply(X, 2, var))
for(i in 1:length(X)){
X[,i] = (X[,i] - Xmu[i])/Xsd[i]
}
for(i in 1:length(Y)){
Y[,i] = Y[,i] - mean(Y[,i])
}
return(list(x = X, y = Y))
}
generateAndNormalize = function(n, transFactorsCount, regulatedGenesPerTF){
set.seed(0)
betas = createBetaFrame()
network = generateNetwork(transFactorsCount, regulatedGenesPerTF)
gamma = 0
weights<-rep(c(regulatedGenesPerTF, rep(1, regulatedGenesPerTF)), transFactorsCount)^((gamma+1)/2)
X = generateExpressionLevelsFrame(n, transFactorsCount, regulatedGenesPerTF)
Y = data.frame(cbind(simulateResponseValues(X, betas[1,]), simulateResponseValues(X, betas[2,]),
simulateResponseValues(X, betas[3,]), simulateResponseValues(X, betas[4,])))
normalized = normalize(X, Y)
return(list(x = normalized[[1]], y = normalized[[2]], net = network, wt = weights))
}
generated = generateAndNormalize(n = 100, transFactorsCount = 200, regulatedGenesPerTF = 10)
X = generated[[1]]
Y = generated[[2]]
network = generated[[3]]
weights = generated[[4]]
View(network)
L = matrix(0, transFactorsCount * ( 1 * regulatedGenesPerTF), transFactorsCount * ( 1 * regulatedGenesPerTF))
transFactorsCount = 200
regulatedGenesPerTF = 10
L = matrix(0, transFactorsCount * ( 1 * regulatedGenesPerTF), transFactorsCount * ( 1 * regulatedGenesPerTF))
L = matrix(0, transFactorsCount * ( 1 + regulatedGenesPerTF), transFactorsCount * ( 1 + regulatedGenesPerTF))
View(L)
p = 20
nrow(network)
p = transFactorsCount * ( 1 + regulatedGenesPerTF)
L = matrix(0, p, p)
for(i in 1:20){
network[i,1]
}
for(i in 1:20){
print(network[i,1])
}
degrees = generated[[4]]
for(i in 1:nrow(network)){
# w(u,v) assumed to be 1
if(network[i,1]==network[i,2]){
L[network[i,1],network[i,2]] = 1 - 1/degrees[i]
} else{
L[network[i,1],network[i,2]] = - 1/sqrt(degrees[i]*degrees[j])
L[network[i,2],network[i,1]] = - 1/sqrt(degrees[i]*degrees[j])
}
}
for(i in 1:nrow(network)){
# w(u,v) assumed to be 1
u = network[i,1]
v = network[i,2]
if(u == v){
L[u,v] = 1 - 1/degrees[u]
} else{
L[u,v] = - 1/sqrt(degrees[u]*degrees[v])
L[v,u] = - 1/sqrt(degrees[u]*degrees[v])
}
}
View(L)
generateNetwork = function(transFactorsCount, regulatedGenesPerTF){
network = matrix(0, transFactorsCount * regulatedGenesPerTF, 2)
for(i in 0:transFactorsCount-1){
for(j in 1:regulatedGenesPerTF){
network[i * regulatedGenesPerTF + j, 1] = i * (regulatedGenesPerTF + 1) + 1
network[i * regulatedGenesPerTF + j, 2] = i * (regulatedGenesPerTF + 1) + j + 1
}
}
gamma = 0
degrees<-rep(c(regulatedGenesPerTF, rep(1, regulatedGenesPerTF)), transFactorsCount)^((gamma+1)/2)
p = transFactorsCount * ( 1 + regulatedGenesPerTF)
L = matrix(0, p, p)
for(i in 1:nrow(network)){
# w(u,v) assumed to be 1
u = network[i,1]
v = network[i,2]
if(u == v){
L[u,v] = 1 - 1/degrees[u]
} else{
L[u,v] = - 1/sqrt(degrees[u]*degrees[v])
L[v,u] = - 1/sqrt(degrees[u]*degrees[v])
}
}
return(L)
}
normalize = function(X, Y){
Xmu<-apply(X, 2, mean)
Xsd<-sqrt(apply(X, 2, var))
for(i in 1:length(X)){
X[,i] = (X[,i] - Xmu[i])/Xsd[i]
}
for(i in 1:length(Y)){
Y[,i] = Y[,i] - mean(Y[,i])
}
return(list(x = X, y = Y))
}
generateAndNormalize = function(n, transFactorsCount, regulatedGenesPerTF){
set.seed(0)
betas = createBetaFrame()
L = generateNetwork(transFactorsCount, regulatedGenesPerTF)
X = generateExpressionLevelsFrame(n, transFactorsCount, regulatedGenesPerTF)
Y = data.frame(cbind(simulateResponseValues(X, betas[1,]), simulateResponseValues(X, betas[2,]),
simulateResponseValues(X, betas[3,]), simulateResponseValues(X, betas[4,])))
normalized = normalize(X, Y)
return(list(x = normalized[[1]], y = normalized[[2]], net = network, dg = degrees))
}
generateAndNormalize = function(n, transFactorsCount, regulatedGenesPerTF){
set.seed(0)
betas = createBetaFrame()
L = generateNetwork(transFactorsCount, regulatedGenesPerTF)
X = generateExpressionLevelsFrame(n, transFactorsCount, regulatedGenesPerTF)
Y = data.frame(cbind(simulateResponseValues(X, betas[1,]), simulateResponseValues(X, betas[2,]),
simulateResponseValues(X, betas[3,]), simulateResponseValues(X, betas[4,])))
normalized = normalize(X, Y)
return(list(x = normalized[[1]], y = normalized[[2]], l = L))
}
generateBetaVector = function(TF1, TF2, TF3, TF4, denominator, negative, positive, unrelatedTransFactorCount){
EL1 = c(TF1, rep(-TF1/denominator, negative), rep(TF1/denominator, positive))
EL2 = c(TF2, rep(-TF2/denominator, negative), rep(TF2/denominator, positive))
EL3 = c(TF3, rep(-TF3/denominator, negative), rep(TF3/denominator, positive))
EL4 = c(TF4, rep(-TF4/denominator, negative), rep(TF4/denominator, positive))
ELU = rep(0, unrelatedTransFactorCount*(1+positive+negative))
return(c(EL1, EL2, EL3, EL4, ELU))
}
createBetaFrame = function(){
M1 = generateBetaVector(TF1 = 5, TF2 = -5, TF3 = 3, TF4 = -3, denominator = sqrt(10), negative = 0, positive = 10, unrelatedTransFactorCount = 196)
M2 = generateBetaVector(TF1 = 5, TF2 = -5, TF3 = 3, TF4 = -3, denominator = sqrt(10), negative = 3, positive = 7, unrelatedTransFactorCount = 196)
M3 = generateBetaVector(TF1 = 5, TF2 = -5, TF3 = 3, TF4 = -3, denominator = 10, negative = 0, positive = 10, unrelatedTransFactorCount = 196)
M4 = generateBetaVector(TF1 = 5, TF2 = -5, TF3 = 3, TF4 = -3, denominator = 10, negative = 3, positive = 7, unrelatedTransFactorCount = 196)
betas = data.frame(rbind(M1,M2,M3,M4))
return(betas)
}
generateExpressionLevels = function(transFactorsCount, regulatedGenesPerTF){
TF = rnorm(n = transFactorsCount, mean = 0, sd = 1)
expressionLevels = c()
for(i in 1:length(TF)){
expressionLevels = c(expressionLevels, TF[i], rnorm(regulatedGenesPerTF, 0.7*TF[i], sqrt(0.51)))
}
return(expressionLevels)
}
generateExpressionLevelsFrame = function(n, transFactorsCount, regulatedGenesPerTF){
expressionLevelsFrame = c()
for(i in 1:n){
expressionLevelsFrame = rbind(expressionLevelsFrame, generateExpressionLevels(transFactorsCount, regulatedGenesPerTF))
}
return(data.frame(expressionLevelsFrame))
}
simulateResponseValues = function(X, betas){
betas = as.numeric(betas)
noiseVar = sum((betas-mean(betas))^2)/4
noise = rnorm(nrow(X), mean = 0, sd = sqrt(noiseVar))
weighedX = sweep(x = X, 2, betas, "*")
sumWeighedX = rowSums(weighedX)
Y = sumWeighedX + noise
return(Y)
}
generateNetwork = function(transFactorsCount, regulatedGenesPerTF){
network = matrix(0, transFactorsCount * regulatedGenesPerTF, 2)
for(i in 0:transFactorsCount-1){
for(j in 1:regulatedGenesPerTF){
network[i * regulatedGenesPerTF + j, 1] = i * (regulatedGenesPerTF + 1) + 1
network[i * regulatedGenesPerTF + j, 2] = i * (regulatedGenesPerTF + 1) + j + 1
}
}
gamma = 0
degrees<-rep(c(regulatedGenesPerTF, rep(1, regulatedGenesPerTF)), transFactorsCount)^((gamma+1)/2)
p = transFactorsCount * ( 1 + regulatedGenesPerTF)
L = matrix(0, p, p)
for(i in 1:nrow(network)){
# w(u,v) assumed to be 1
u = network[i,1]
v = network[i,2]
if(u == v){
L[u,v] = 1 - 1/degrees[u]
} else{
L[u,v] = - 1/sqrt(degrees[u]*degrees[v])
L[v,u] = - 1/sqrt(degrees[u]*degrees[v])
}
}
return(L)
}
normalize = function(X, Y){
Xmu<-apply(X, 2, mean)
Xsd<-sqrt(apply(X, 2, var))
for(i in 1:length(X)){
X[,i] = (X[,i] - Xmu[i])/Xsd[i]
}
for(i in 1:length(Y)){
Y[,i] = Y[,i] - mean(Y[,i])
}
return(list(x = X, y = Y))
}
generateAndNormalize = function(n, transFactorsCount, regulatedGenesPerTF){
set.seed(0)
betas = createBetaFrame()
L = generateNetwork(transFactorsCount, regulatedGenesPerTF)
X = generateExpressionLevelsFrame(n, transFactorsCount, regulatedGenesPerTF)
Y = data.frame(cbind(simulateResponseValues(X, betas[1,]), simulateResponseValues(X, betas[2,]),
simulateResponseValues(X, betas[3,]), simulateResponseValues(X, betas[4,])))
normalized = normalize(X, Y)
return(list(x = normalized[[1]], y = normalized[[2]], l = L))
}
generated = generateAndNormalize(n = 100, transFactorsCount = 200, regulatedGenesPerTF = 10)
X = generated[[1]]
Y = generated[[2]]
L = generated[[3]]
View(L)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("dataset_tools.R")
source("grace.R")
generated = generateAndNormalize(n = 100, transFactorsCount = 20, regulatedGenesPerTF = 10)
X = generated[[1]]
Y = generated[[2]]
L = generated[[3]]
lambdaGrid = grid = 10 ^ seq(10, -2, length = 5)
res = grace(Y[,1], X, L, lambdaGrid, lambdaGrid, lambdaGrid, K = 10)
lambdaGrid = grid = 10 ^ seq(10, -1, length = 5)
seq(10, -1, length = 5)
lambdaGrid = grid = 10 ^ seq(10, -2, length = 5)
seq(10, -2, length = 5)
seq(10, -2, length = 10)
seq(-2, 1, length = 10)
seq(from = -2, by = 1, length = 10)
lambdaGrid = seq(from = -2, by = 1, length = 10)
lambdaGrid = 10 ^ seq(from = -2, by = 1, length = 10)
lambdaGrid = 10 ^ seq(from = -2, by = 1, length = 5)
res = grace(Y[,1], X, L, lambdaGrid, lambdaGrid, lambdaGrid, K = 10)
lambdaGrid = 10 ^ seq(from = 1, by = 1, length = 5)
res = grace(Y[,1], X, L, lambdaGrid, lambdaGrid, lambdaGrid, K = 10)
lambdaGrid = 10 ^ seq(from = -2, by = 1, length = 8)
res = grace(Y[,1], X, L, lambdaGrid, lambdaGrid, lambdaGrid, K = 10)
lambdaGrid = 10 ^ seq(from = -2, by = 1, length = 6)
res = grace(Y[,1], X, L, lambdaGrid, lambdaGrid, lambdaGrid, K = 10)
